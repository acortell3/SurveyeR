

## Load necessary libraries
library(MASS) # fractions
library(extraDistr) ## for ddirmnom


### Function 1. Learning process
#' @title Infer
#' @description It provides the theoretical probability distribution of the
#' types given the control (or any) dataset and a non-informative prior
#' @param data: A data.frame with the known data where the first column is the
#'  assigned period and successive columns are the ordered types
#' @param periods: A factor where the name of each value is the site/level
#' and the value is the period to which the site/level corresponds.
#' @param prior: Prior to be selected. Options are "Haldane", "Jeffreys", "Perk",
#' "BayesLaplace","Hierarchical". Default is "Perk".
#' @returns A list where each element is the period. Each element/period is a data frame
#' with the curve for each type
#' @export

Infer <- function(data, prior = "Perk"){

  ## Standardise name for first column
  colnames(data)[1] <- "Period"

  # How many periods
  P <- length(levels(as.factor(data$Period)))

  # How many types
  Ty <- ncol(data)-1

  ## Vector with arrow type to create data frames
  svaria <- paste0("Type.",seq(1,Ty))

  ## Select prior
  if (prior == "Haldane"){
    teo_distribution <- 0
  } else if (prior == "Jeffreys"){
    teo_distribution <- 1/2
  } else if (prior == "Perk"){
    teo_distribution <- 1/Ty
  } else if (prior == "BayesLaplace"){
    teo_distribution <- 1
  } else if (prior == "Hierarchical"){
    teo_distribution <- sqrt(2)/Ty
  }

  # Utility to help with the beta distribution
  x <- seq(0,1,length=1000)

  # To store the results
  periods_train <- list()

  for (i in 1:P){
    newdata <- subset(data,Period == i, svaria)

    sum_newdata <- list()
    ys <- list()

    for (j in 1:Ty){
      ## Data frames with the sum of type [j] in period [i]
      sum_newdata[[j]] <- sum(newdata[,j])
      ## Data frame with the proportions of type [j] in period [i]
      ys[[j]] <- fractions(sum(newdata[,j])+teo_distribution)
    }

    # create a new data.frame with the sum of the rest of type[j] in period[i] (result in proportions)
    ybs <- list()
    ytot <- sum(unlist(ys))

    for (j in 1:Ty){
      ybs[[j]] <- ytot-ys[[j]]
    }

    # create a new data.frame with marginal distribution for type[j] in period[i]
    type <- list()
    for (j in 1:Ty){
      type[[j]] <- dbeta(x, ys[[j]], ybs[[j]])
    }

    # create a vector with the combination of all marginal distributions
    beta_dist <- as.data.frame(matrix(unlist(type), ncol = Ty))
    colnames(beta_dist) <- paste0("Type.", 1:Ty)

    periods_train[[i]] <- beta_dist
    names(periods_train)[[i]] <- paste("period_",i)

  }
  return(periods_train)
}


### Function 2. Predict specific site
#' @title Phase.pred
#' Returns a list. In the list each element is a period and each period
#' contains the inferred distribution of each type (for that period) as a
#' data frame. The name of each element of the list is the name of the period.
#' @param dated: A data.frame with the known data where the first column is the
#'  assigned period and successive columns are the ordered types
#' @param estimate: Data on which we want to estimate. Rownames are the names of
#' the sites and are used to compute the probability, so they must be correct.
#' Columns are number of each type per site
#' @param prior: Prior to be selected. Options are "Haldane", "Jeffreys", "Perk",
#' "BayesLaplace","Hierarchical". Default is "Perk".
#' @param site: The site on which we want to estimate. It must be spelled as in
#' the rownames
#' @returns a vector with the prediction for the selected site where each position
#' is the probability per period
#' @export

Phase.pred <- function(dated, estimate, prior = "Perk", site){

  ## Define periods

  ## Standardise name for first column
  colnames(dated)[1] <- "Period"

  ## Total dates sites
  tds <- nrow(dated)

  ## Total number of periods
  Ps <- length(levels(as.factor(dated$Period)))

  ## A vector where each value is the number of sites in that period
  prs <- c(rep(NA,Ps))
  for (i in 1:length(prs)){
    prs[i] <- nrow(subset(dated,Period == i))
  }

  # Defines P(m* = m[i] | D)
  est.p <- c(prs/tds)

  ## Switch to types

  ## Vector with arrow type to create data frames
  svaria <- colnames(dated)[-1]

  ## List with subsets of types per period
  post <- list()
  for (i in 1:length(prs)){
    post[[i]] <- subset(dated, Period == i, svaria)
  }

  ## Select prior
  if (prior == "Haldane"){
    teo_distribution <- 0
  } else if (prior == "Jeffreys"){
    teo_distribution <- 1/2
  } else if (prior == "Perk"){
    teo_distribution <- 1/length(svaria)
  } else if (prior == "BayesLaplace"){
    teo_distribution <- 1
  } else if (prior == "Hierarchical"){
    teo_distribution <- sqrt(2)/length(svaria)
  }

  ## Compute Dirichlet probabilities
  types <- list()
  y <- list()
  Dir.res <- list()

  for (j in 1:length(post)){
    for (i in 1:length(svaria)){
      types[[i]] <- sum(post[[j]][,i])
    }

    for (i in 1:length(svaria)){
      y[[i]] <- fractions(types[[i]] + teo_distribution)
    }

    Dir.res[[j]] <- unlist(y)
  }

  ## Select the site to observe
  y.star <- subset(estimate[,-1], rownames(estimate) == site)
  y.star <- y.star
  n.star <-sum(y.star)

  ## Compute the likelihood
  likelihood <- rep(NA,length(post))

  for (i in 1:length(post)){
    likelihood[i] <- ddirmnom(y.star, n.star, as.numeric(Dir.res[[i]]))
  }

  ## Results
  res <- likelihood*est.p /sum(likelihood*est.p)
  names(res) <- paste0("Period.", 1:length(res))
  return(res)

}


